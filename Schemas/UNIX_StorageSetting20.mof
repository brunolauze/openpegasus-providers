//%LICENSE////////////////////////////////////////////////////////////////
//
// Licensed to The Open Group (TOG) under one or more contributor license
// agreements.  Refer to the OpenPegasusNOTICE.txt file distributed with
// this work for additional information regarding copyright ownership.
// Each contributor licenses this file to you under the OpenPegasus Open
// Source License; you may not use this file except in compliance with the
// License.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//////////////////////////////////////////////////////////////////////////
//
//%/////////////////////////////////////////////////////////////////////////



// Copyright (c) 2009 DMTF.  All rights reserved.
   [Abstract, Version ( "2.19.0" ), 
    UMLPackagePath ( "CIM::Core::CoreElements" ), 
    Description ( 
       "ManagedElement is an abstract class that provides a common "
       "superclass (or top of the inheritance tree) for the "
       "non-association classes in the CIM Schema." )]
class CIM_ManagedElement {

      [Description ( 
          "InstanceID is an optional property that may be used to "
          "opaquely and uniquely identify an instance of this class "
          "within the scope of the instantiating Namespace. Various "
          "subclasses of this class may override this property to "
          "make it required, or a key. Such subclasses may also "
          "modify the preferred algorithms for ensuring uniqueness "
          "that are defined below.\n"
          "To ensure uniqueness within the NameSpace, the value of "
          "InstanceID should be constructed using the following "
          "\"preferred\" algorithm: \n"
          "<OrgID>:<LocalID> \n"
          "Where <OrgID> and <LocalID> are separated by a colon "
          "(:), and where <OrgID> must include a copyrighted, "
          "trademarked, or otherwise unique name that is owned by "
          "the business entity that is creating or defining the "
          "InstanceID or that is a registered ID assigned to the "
          "business entity by a recognized global authority. (This "
          "requirement is similar to the <Schema Name>_<Class Name> "
          "structure of Schema class names.) In addition, to ensure "
          "uniqueness, <OrgID> must not contain a colon (:). When "
          "using this algorithm, the first colon to appear in "
          "InstanceID must appear between <OrgID> and <LocalID>. \n"
          "<LocalID> is chosen by the business entity and should "
          "not be reused to identify different underlying "
          "(real-world) elements. If not null and the above "
          "\"preferred\" algorithm is not used, the defining entity "
          "must assure that the resulting InstanceID is not reused "
          "across any InstanceIDs produced by this or other "
          "providers for the NameSpace of this instance. \n"
          "If not set to null for DMTF-defined instances, the "
          "\"preferred\" algorithm must be used with the <OrgID> "
          "set to CIM." )]
   string InstanceID;

      [Description ( 
          "The Caption property is a short textual description "
          "(one- line string) of the object." ), 
       MaxLen ( 64 )]
   string Caption;

      [Description ( 
          "The Description property provides a textual description "
          "of the object." )]
   string Description;

      [Description ( 
          "A user-friendly name for the object. This property "
          "allows each instance to define a user-friendly name in "
          "addition to its key properties, identity data, and "
          "description information. \n"
          "Note that the Name property of ManagedSystemElement is "
          "also defined as a user-friendly name. But, it is often "
          "subclassed to be a Key. It is not reasonable that the "
          "same property can convey both identity and a "
          "user-friendly name, without inconsistencies. Where Name "
          "exists and is not a Key (such as for instances of "
          "LogicalDevice), the same information can be present in "
          "both the Name and ElementName properties. Note that if "
          "there is an associated instance of "
          "CIM_EnabledLogicalElementCapabilities, restrictions on "
          "this properties may exist as defined in ElementNameMask "
          "and MaxElementNameLen properties defined in that class." )]
   string ElementName;

      [Experimental, Description ( 
          "Generation is an optional, monotonically increasing "
          "property that may be used to identify a particular "
          "generation of the resource represented by this class.\n"
          "If Generation is supported by the implementation, its "
          "value shall not be null. \n"
          "Except as otherwise specified, a value (including null) "
          "of Generation specified at creation time shall be "
          "replaced by null if Generation is not supported by the "
          "implementation or shall be a, (possibly different), "
          "non-null value if the implementation does support Generation.\n"
          "After creation and if supported, Generation shall be "
          "updated, at least once per access, whenever the "
          "represented resource is modified, regardless of the "
          "source of the modification.\n"
          "Note: the Generation value only needs to be updated once "
          "between references, even if the resource is updated many "
          "times. The key point is to assure that it will be "
          "different if there have been updates, not to count each update.\n"
          "Note: unless otherwise specified, the value of "
          "Generation within one instance is not required to be "
          "coordinated with the value of Generation in any other instance.\n"
          "Note:the semantics of the instance, (as defined by its "
          "creation class), define the underlying resource. That "
          "underlying resource may be a collection or aggregation "
          "of resources. And, in that case, the semantics of the "
          "instance further define when updates to constituent "
          "resources also require updates to the Generation of the "
          "collective resource. Default behavior of composite "
          "aggregations should be to update the Generation of the "
          "composite whenever the Generation of a component is updated.\n"
          "Subclasses may define additional requirements for "
          "updates on some or all of related instances.\n"
          "For a particular instance, the value of Generation may "
          "wrap through zero, but the elapsed time between wraps "
          "shall be greater than 10\'s of years.\n"
          "This class does not require Generation to be unique "
          "across instances of other classes nor across instances "
          "of the same class that have different keys. Generation "
          "shall be different across power cycles, resets, or "
          "reboots if any of those actions results in an update. "
          "Generation may be different across power cycles, resets, "
          "or reboots if those actions do not result in an update. "
          "If the Generation property of an instance is non-null, "
          "and if any attempt to update the instance includes the "
          "Generation property, then if it doesn\'t match the "
          "current value, the update shall fail.\n"
          "The usage of this property is intended to be further "
          "specified by applicable management profiles. \n"
          "Typically, a client will read the value of this property "
          "and then supply that value as input to an operation that "
          "modifies the instance in some means. This may be via an "
          "explicit parameter in an extrinsic method or via an "
          "embedded value in an extrinsic method or intrinsic operation.\n"
          "For example: a profile may require that an intrinsic "
          "instance modification supply the Generation property and "
          "that it must match for the modification to succeed." )]
   uint64 Generation;


};



// Copyright (c) 2013 DMTF.  All rights reserved.
   [Abstract, Version ( "2.38.0" ), 
    ClassConstraint { "inv: SoID <> null implies SoOrgID <> null" }, 
    UMLPackagePath ( "CIM::Core::Settings" ), 
    Description ( 
       "CIM_SettingData is used to represent configuration and and "
       "operational parameters for CIM_ManagedElement instances. There "
       "are a number of different uses of CIM_SettingData supported in "
       "the model today. Additional uses may be defined in the future.\n"
       "Instances of CIM_SettingData may represent Aspects of a "
       "CIM_ManagedElement instance. This is modeled using the "
       "CIM_SettingsDefineState association. CIM_SettingData may be "
       "used to define capabilities when associated to an instance of "
       "CIM_Capabilities through the CIM_SettingsDefineCapabilities "
       "association. \n"
       "Instances of CIM_SettingData may represent different types of "
       "configurations for a CIM_ManagedElement, including persistent "
       "configurations, in progress configuration changes, or "
       "requested configurations. The CIM_ElementSettingData "
       "association is used to model the relationship between a "
       "CIM_SettingData instance and the CIM_ManagedElement for which "
       "it is a configuration. \n"
       "When an instance of CIM_SettingData represents a "
       "configuration, the current operational values for the "
       "parameters of the element are reflected by properties in the "
       "Element itself or by properties in its associations. These "
       "properties do not have to be the same values that are present "
       "in the SettingData object. For example, a modem might have a "
       "SettingData baud rate of 56Kb/sec but be operating at "
       "19.2Kb/sec. \n"
       "Note: The CIM_SettingData class is very similar to "
       "CIM_Setting, yet both classes are present in the model because "
       "many implementations have successfully used CIM_Setting. "
       "However, issues have arisen that could not be resolved without "
       "defining a new class. Therefore, until a new major release "
       "occurs, both classes will exist in the model. Refer to the "
       "Core White Paper for additional information. SettingData "
       "instances can be aggregated together into higher- level "
       "SettingData objects using ConcreteComponent associations." )]
class CIM_SettingData : CIM_ManagedElement {

      [Key, Override ( "InstanceID" ), 
       Description ( 
          "Within the scope of the instantiating Namespace, "
          "InstanceID opaquely and uniquely identifies an instance "
          "of this class. To ensure uniqueness within the "
          "NameSpace, the value of InstanceID should be constructed "
          "using the following \"preferred\" algorithm: \n"
          "<OrgID>:<LocalID> \n"
          "Where <OrgID> and <LocalID> are separated by a colon "
          "(:), and where <OrgID> must include a copyrighted, "
          "trademarked, or otherwise unique name that is owned by "
          "the business entity that is creating or defining the "
          "InstanceID or that is a registered ID assigned to the "
          "business entity by a recognized global authority. (This "
          "requirement is similar to the <Schema Name>_<Class Name> "
          "structure of Schema class names.) In addition, to ensure "
          "uniqueness, <OrgID> must not contain a colon (:). When "
          "using this algorithm, the first colon to appear in "
          "InstanceID must appear between <OrgID> and <LocalID>. \n"
          "<LocalID> is chosen by the business entity and should "
          "not be reused to identify different underlying "
          "(real-world) elements. If the above \"preferred\" "
          "algorithm is not used, the defining entity must assure "
          "that the resulting InstanceID is not reused across any "
          "InstanceIDs produced by this or other providers for the "
          "NameSpace of this instance. \n"
          "For DMTF-defined instances, the \"preferred\" algorithm "
          "must be used with the <OrgID> set to CIM." )]
   string InstanceID;

      [Required, Override ( "ElementName" ), 
       Description ( 
          "The user-friendly name for this instance of SettingData. "
          "In addition, the user-friendly name can be used as an "
          "index property for a search or query. (Note: The name "
          "does not have to be unique within a namespace.)" )]
   string ElementName;

      [Description ( 
          "An instance of CIM_SettingData may correspond to a "
          "well-known configuration that exists for an associated "
          "CIM_ManagedElement. If the ConfigurationName property is "
          "non-NULL, the instance of CIM_SettingData shall "
          "correspond to a well-known configuration for a Managed "
          "Element, the value of the ConfigurationName property "
          "shall be the name of the configuration, and the "
          "ChangeableType property shall have the value 0 or 2. A "
          "value of NULL for the ConfigurationName property shall "
          "mean that the instance of CIM_SettingData does not "
          "correspond to a well-known configuration for a Managed "
          "Element or that this information is unknown." )]
   string ConfigurationName;

      [Description ( 
          "Enumeration indicating the type of setting. 0 \"Not "
          "Changeable - Persistent\" indicates the instance of "
          "SettingData represents primordial settings and shall not "
          "be modifiable. 1 \"Changeable - Transient\" indicates "
          "the SettingData represents modifiable settings that are "
          "not persisted. Establishing persistent settings from "
          "transient settings may be supported. 2 \"Changeable - "
          "Persistent\" indicates the SettingData represents a "
          "persistent configuration that may be modified. 3 \"Not "
          "Changeable - Transient\" indicates the SettingData "
          "represents a snapshot of the settings of the associated "
          "ManagedElement and is not persistent." ), 
       ValueMap { "0", "1", "2", "3" }, 
       Values { "Not Changeable - Persistent", 
          "Changeable - Transient", "Changeable - Persistent", 
          "Not Changeable - Transient" }]
   uint16 ChangeableType;

      [Experimental, Description ( 
          "The value of each CIM_ComponentSetting instance includes "
          "a CIM_SettingData instance that specifies further values "
          "for this CIM_SettingData instance. The values are "
          "interpreted according to the values of the Policy, "
          "ValueRole, and ValueRange properties included in each "
          "CIM_ComponentSetting instance.\n"
          "\n"
          "Note: If SoID is not null, then the embedded "
          "ComponentSetting elements may be interpreted as ITIL "
          "Service Level Targets.\n"
          "Note: For CIM v3, the type of ComponentSetting will be "
          "CIM_ComponentSetting. This is not represented as an "
          "EmbeddedInstance in CIM v2 to avoid a circular "
          "dependency that CIM v2 compilers cannot handle." ), 
       EmbeddedObject]
   string ComponentSetting[];

      [Experimental, Description ( 
          "If not Null, the CIM_SettingData instance is being used "
          "to represent an ITIL element: either a service option, a "
          "service level requirement, or a service level target. "
          "The value SoID must be unique in the context of an "
          "Organization unique identifier specified in SoOrgID." ), 
       ModelCorrespondence { "CIM_SettingData.SoOrgID" }]
   string SoID;

      [Experimental, Description ( 
          "If not Null, the CIM_SettingData instance is being used "
          "to represent an ITIL element: either a service option, a "
          "service level requirement, or a service level target. "
          "When not Null, the value of SoOrgID shall be a unique "
          "identifier for the organization that specifies the value "
          "of SoID." ), 
       ModelCorrespondence { "CIM_SettingData.SoID" }]
   string SoOrgID;


};



// Copyright (c) 2012 DMTF.  All rights reserved.
   [Version ( "2.35.0" ), 
    UMLPackagePath ( "CIM::Device::StorageServices" ), 
    Description ( 
       "StorageSetting is roughly equivalent to a Service Level "
       "Agreement (SLA) It defines the characteristics, qualities of "
       "service and goals when used in a CreateOrModifyElement "
       "FromStoragePool or CreateOrModifyStoragePool method in the "
       "StorageConfigurationService. It specifies a series of "
       "properties with Maximum and Minimum values that define the "
       "(inclusive) bounds that the object should maintain. Note that "
       "the setting is associated to a StorageVolume or LogicalDisk, "
       "using ElementSetting. \n"
       "The use of these properties differs depending on whether the "
       "StorageSetting instance is being used as a goal for a "
       "configuration operation or being used as a Service Level "
       "Agreement for a created Volume. In addition the properties "
       "fall into two categories: The QOS "
       "properties(PackageRedundancy, Data Redundancy, & "
       "NoSinglePointOfFailure) and the Detailed RAID "
       "properties(ExtentStripeLength, ParityLayout, and "
       "UserDataStripeDepth). In a Setting used as a goal, the QOS "
       "properties are required as a set; The Detailed RAID "
       "properties(if supported as indicated by the scoping "
       "StorageCapabilities instance) may be used optionally in any "
       "combination. The implementation MUST supply it\'s own best "
       "practice in the case where one or more supported RAID "
       "properties are not supplied. In this situation the use of "
       "StorageSettingWithHints can be useful to provide direction to "
       "the implementation. \n"
       "In a Setting used as a service agreement for a Volume, the QOS "
       "properties reflect the Service Level Agreement, with goal, "
       "min, & max. The actual current service level is exposed by "
       "corresponding values in StorageExtent. \n"
       "The Detailed RAID properties, by contrast, reflect specific "
       "values that reflect the RAID construction of the Volume. Only "
       "the primary values are meaningful; Min and Max are set to "
       "match. \n"
       "Certain StorageSetting instances may be classed as \"Fixed\", "
       "by using the \"ChangeableType\" property, indicating the "
       "setting is preset. Such settings are used when the possible "
       "setting variations are low enough to be instantiated in their "
       "entirety. The StorageCapabilities \"CreateSetting\" method MAY "
       "NOT be used to return settings that are not changeable. \n"
       "Other StorageSetting instances are created using the "
       "\"CreateSetting\" method. If the capabilities specifies "
       "ranges, then the setting can be used by a client to narrow the "
       "range to particular values within the range. In other words, "
       "the capabilities MAY be broad, but the related setting MUST be "
       "as capable or less capable, that is more narrowly defined, "
       "before it is used to create or modify resources. \n"
       "These created StorageSetting instances MUST have their "
       "\"ChangeableType\" property = 1, \"Changeable - Transient\". \n"
       "GeneratedSettings MAY not remain after the restart or reset of "
       "the implementation. They may be deleted by implementation at "
       "any time. A reasonable minimal time to retain the generated "
       "transient settings is five minutes, although there is no "
       "minimal retention time." )]
class CIM_StorageSetting : CIM_SettingData {

      [Write, Description ( 
          "Indicates the desired value for No Single Point of "
          "Failure. Possible values are false = single point of "
          "failure, and true = no single point of failure." )]
   boolean NoSinglePointOfFailure;

      [Write, Description ( 
          "DataRedundancyMax describes the maximum number of "
          "complete copies of data to be maintained. Examples would "
          "be RAID 5 where 1 copy is maintained and RAID 1 where 2 "
          "or more copies are maintained. Possible values are 1 to "
          "n. The desired redundancy is specified using "
          "DataRedundancyGoal, while the minimum is defined by "
          "DataRedundancyMin." ), 
       MinValue ( 1 ), 
       ModelCorrespondence { "CIM_StorageSetting.DataRedundancyMin", 
          "CIM_StorageSetting.DataRedundancyGoal" }]
   uint16 DataRedundancyMax;

      [Write, Description ( 
          "DataRedundancyMin describes the minimum number of "
          "complete copies of data to be maintained. Examples would "
          "be RAID 5 where 1 copy is maintained and RAID 1 where 2 "
          "or more copies are maintained. Possible values are 1 to "
          "n. The desired redundancy is specified using "
          "DataRedundancyGoal, while the maximum is defined by "
          "DataRedundancyMax." ), 
       MinValue ( 1 ), 
       ModelCorrespondence { "CIM_StorageSetting.DataRedundancyMax", 
          "CIM_StorageSetting.DataRedundancyGoal" }]
   uint16 DataRedundancyMin;

      [Write, Description ( 
          "DataRedundancyGoal describes the desired number of "
          "complete copies of data to be maintained. Examples would "
          "be RAID 5 where 1 copy is maintained and RAID 1 where 2 "
          "or more copies are maintained. Possible values are 1 to "
          "n. The bounds (max and min) for redundancy are defined "
          "using the properties, DataRedundancyMax and "
          "DataRedundancyMin." ), 
       MinValue ( 1 ), 
       ModelCorrespondence { "CIM_StorageSetting.DataRedundancyMax", 
          "CIM_StorageSetting.DataRedundancyMin" }]
   uint16 DataRedundancyGoal;

      [Write, Description ( 
          "PackageRedundancyMax describes the maximum number of "
          "redundant packages to be used. For example, in the "
          "storage domain, package redundancy describes how many "
          "disk spindles can fail without data loss including, at "
          "most, one spare. An example would be RAID5 with a spare "
          "disk which would have a PackageRedundancy of 2. Possible "
          "values are 0 to n. The desired redundancy is specified "
          "using PackageRedundancyGoal, while the minimum is "
          "defined by PackageRedundancyMin." ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.PackageRedundancyMin", 
          "CIM_StorageSetting.PackageRedundancyGoal" }]
   uint16 PackageRedundancyMax;

      [Write, Description ( 
          "PackageRedundancyMin describes the minimum number of "
          "redundant packages to be used. For example, in the "
          "storage domain, package redundancy describes how many "
          "disk spindles can fail without data loss including, at "
          "most, one spare. An example would be RAID5 with a spare "
          "disk which would have a PackageRedundancy of 2. Possible "
          "values are 0 to n. The desired redundancy is specified "
          "using PackageRedundancyGoal, while the maximum is "
          "defined by PackageRedundancyMax." ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.PackageRedundancyMax", 
          "CIM_StorageSetting.PackageRedundancyGoal" }]
   uint16 PackageRedundancyMin;

      [Write, Description ( 
          "PackageRedundancyGoal describes the desired number of "
          "redundant packages to be used. For example, in the "
          "storage domain, package redundancy describes how many "
          "disk spindles can fail without data loss including, at "
          "most, one spare. An example would be RAID5 with a spare "
          "disk which would have a PackageRedundancy of 2. Possible "
          "values are 0 to n. The bounds (max and min) for "
          "redundancy are defined using the properties, "
          "PackageRedundancyMax and PackageRedundancyMin." ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.PackageRedundancyMax", 
          "CIM_StorageSetting.PackageRedundancyMin" }]
   uint16 PackageRedundancyGoal;

      [Write, Description ( 
          "DeltaReservationMax is a number between 1 (1%) and a 100 "
          "(100%) which specifies the maximum amount of space that "
          "should be reserved in a replica for caching changes. For "
          "a complete copy this would be 100%. The desired "
          "reservation is specified using DeltaReservationGoal, "
          "while the minimum is defined by DeltaReservationMin." ), 
       Units ( "Percentage" ), 
       MinValue ( 1 ), 
       MaxValue ( 100 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.DeltaReservationMin", 
          "CIM_StorageSetting.DeltaReservationGoal" }, 
       PUnit ( "percent" )]
   uint8 DeltaReservationMax;

      [Write, Description ( 
          "DeltaReservationMin is a number between 1 (1%) and a 100 "
          "(100%) which specifies the minimum amount of space that "
          "should be reserved in a replica for caching changes. For "
          "a complete copy this would be 100%. The desired "
          "reservation is specified using DeltaReservationGoal, "
          "while the maximum is defined by DeltaReservationMax." ), 
       Units ( "Percentage" ), 
       MinValue ( 1 ), 
       MaxValue ( 100 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.DeltaReservationMax", 
          "CIM_StorageSetting.DeltaReservationGoal" }, 
       PUnit ( "percent" )]
   uint8 DeltaReservationMin;

      [Write, Description ( 
          "DeltaReservationGoal is a number between 1 (1%) and a "
          "100 (100%) which specifies the desired amount of space "
          "that should be reserved in a replica for caching "
          "changes. For a complete copy this would be 100%. The "
          "bounds (max and min) for the reservation are defined "
          "using the properties, DeltaReservationMax and "
          "DeltaReservationMin." ), 
       Units ( "Percentage" ), 
       MinValue ( 1 ), 
       MaxValue ( 100 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.DeltaReservationMin", 
          "CIM_StorageSetting.DeltaReservationMax" }, 
       PUnit ( "percent" )]
   uint8 DeltaReservationGoal;

      [Override ( "ChangeableType" ), 
       Description ( 
          "Enumeration indicating the type of setting. \"Fixed - "
          "Not Changeable\" settings are primordial. These setting "
          "are defined at the implementor of the class. \"Changeable "
          "- Transient\" is the type of setting produced by the "
          "\"CreateSetting\" method. A client can subsequently "
          "request that the implementation persist the generated "
          "and potentially modified setting indefinately. Only a "
          "\"Changeable - Transient\" setting SHALL be converted to "
          "a \"Changeable = Persistent\" setting; the setting SHALL "
          "NOT be changed back." ), 
       ValueMap { "0", "1", "2" }, 
       Values { "Fixed - Not Changeable", "Changeable - Transient", 
          "Changeable - Persistent" }]
   uint16 ChangeableType;

      [Write, Description ( 
          "ExtentStripeLength describes the number of underlying "
          "StorageExtents across which data is striped in the "
          "common striping-based storage organizations. This is "
          "also known as the number of \'members\' or \'columns\'. "
          "When used in a goal setting instance, ExtentStripeLength "
          "is the optimal desired value. The bounds (max and min) "
          "for Stripe Length are defined using the properties "
          "ExtentStripeLengthMax and ExtentStripeLengthMin. "
          "ExtentStripeLength MUST be set to NULL if the scoping "
          "StorageCapablities indicates that it is not supported in "
          "this context. ExtentStripeLength can be used in "
          "conjunction with CreateOrModifyElementFromELements to "
          "explicitly configure storage. An example would be RAID "
          "0+1 with mirroring two stripe sets, each set being three "
          "wide. In this case CreateOrModifyElementFromElements "
          "would be passed a goal setting with DataRedundancy = 2 "
          "and ExtentStripeLength = 3. The size of the InElements "
          "array would be 6 and would contain the StorageExtents to "
          "be used to construct the StorageElement as a RAID 0+1. "
          "ExtentStripeLengthMin and ExtentStripeLengthMax are "
          "meaningless and wouldbe set to NULL. If the property is "
          "supported, and is part of StorageSettingWithHints it MAY "
          "be set to NULL. If used it will constrain the effects of "
          "Hint selections. When used in a Setting instance "
          "associated to a Volume, this property indicates the "
          "specific value that the Volume was created with, and "
          "ExtentStripeLengthMin and ExtentStripeLengthMax will be "
          "set to the same specific value." ), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.ExtentStripeLengthMax", 
          "CIM_StorageSetting.ExtentStripeLengthMin" }]
   uint16 ExtentStripeLength;

      [Write, Description ( 
          "ExtentStripeLength describes the number of underlying "
          "StorageExtents across which data is striped in the "
          "common striping-based storage organizations. This is "
          "also known as the number of \'members\' or \'columns\'. "
          "When used in a goal setting instance, "
          "ExtentStripeLengthMin is the minimum acceptable value. "
          "The desired Stripe Length is specified using "
          "ExtentStripeLength, while the maximum is defined by "
          "ExtentStripeLengthMax. ExtentStripeLengthMin MUST be set "
          "to NULL if the scoping StorageCapablities indicates that "
          "it is not supported in this context. If the property is "
          "supported, and is part of StorageSettingWithHints it MAY "
          "be set to NULL. If used it will constrain the effects of "
          "Hint selections. When used in a Setting instance "
          "associated to a Volume, this property is set to the "
          "specific value of ExtentStripeLength." ), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.ExtentStripeLengthMax", 
          "CIM_StorageSetting.ExtentStripeLength" }]
   uint16 ExtentStripeLengthMin;

      [Write, Description ( 
          "ExtentStripeLength describes the number of underlying "
          "StorageExtents across which data is striped in the "
          "common striping-based storage organizations. This is "
          "also known as the number of \'members\' or \'columns\'. "
          "When used in a goal setting instance, "
          "ExtentStripeLengthMax is the maximum acceptable value. "
          "The desired Stripe Length is specified using "
          "ExtentStripeLength, while the minimum is defined by "
          "ExtentStripeLengthMin. ExtentStripeLengthMax MUST be set "
          "to NULL if the scoping StorageCapablities indicates that "
          "it is not supported in this context. If the property is "
          "supported, and is part of StorageSettingWithHints it MAY "
          "be set to NULL. If used it will constrain the effects of "
          "Hint selections. When used in a Setting instance "
          "associated to a Volume, this property is set to the "
          "specific value of ExtentStripeLength." ), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.ExtentStripeLengthMin", 
          "CIM_StorageSetting.ExtentStripeLength" }]
   uint16 ExtentStripeLengthMax;

      [Write, Description ( 
          "ParityLayout specifies whether a parity-based storage "
          "organization is using rotated or non-rotated parity. "
          "When used in a goal setting instance, ParityLayout is "
          "the desired value. It MUST be set to NULL if the scoping "
          "StorageCapablities indicates that it is not supported in "
          "this context. If the property is supported, and is part "
          "of StorageSettingWithHints it MAY be set to NULL. If "
          "used it will constrain the effects of Hint selections. "
          "When used in a Setting instance associated to a Volume, "
          "this property indicates the specific value that the "
          "Volume was created with." ), 
       ValueMap { "1", "2" }, 
       Values { "Non-rotated Parity", "Rotated Parity" }]
   uint16 ParityLayout;

      [Write, Description ( 
          "UserDataStripeDepth describes the number of bytes "
          "forming a strip in common striping-based storage "
          "organizations. The strip is defined as the size of the "
          "portion of a stripe that lies on one extent. Thus, "
          "ExtentStripeLength * UserDataStripeDepth will yield the "
          "size of one stripe of user data. When used in a goal "
          "setting instance, UserDataStripeDepth is the optimal "
          "desired value. The bounds (max and min) for Stripe Depth "
          "are defined using the properties UserDataStripeDepthMax "
          "and UserDataStripeDepthMin. UserDataStripeDepth MUST be "
          "set to NULL if the scoping StorageCapablities indicates "
          "that it is not supported in this context. If the "
          "property is supported, and is part of "
          "StorageSettingWithHints it MAY be set to NULL. If used "
          "it will constrain the effects of Hint selections. When "
          "used in a Setting instance associated to a Volume, this "
          "property indicates the specific value that the Volume "
          "was created with, and UserDataStripeDepthMin and "
          "UserDataStripeDepthMax will be set to the same specific "
          "value." ), 
       Units ( "Bytes" ), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.UserDataStripeDepthMax", 
          "CIM_StorageSetting.UserDataStripeDepthMin" }, 
       PUnit ( "byte" )]
   uint64 UserDataStripeDepth;

      [Write, Description ( 
          "UserDataStripeDepth describes the number of bytes "
          "forming a strip in common striping-based storage "
          "organizations. The strip is defined as the size of the "
          "portion of a stripe that lies on one extent. Thus, "
          "ExtentStripeLength * UserDataStripeDepth will yield the "
          "size of one stripe of user data. When used in a goal "
          "setting instance, UserDataStripeDepthMin is the minimum "
          "acceptable value. The desired Stripe Depth is specified "
          "using UserDataStripeDepth, while the maximum is defined "
          "by UserDataStripeDepthMax. UserDataStripeDepthMin MUST "
          "be set to NULL if the scoping StorageCapablities "
          "indicates that it is not supported in this context. If "
          "the property is supported, and is part of "
          "StorageSettingWithHints it MAY be set to NULL. If used "
          "it will constrain the effects of Hint selections. When "
          "used in a Setting instance associated to a Volume, this "
          "property is set to the specific value of "
          "UserDataStripeDepth." ), 
       Units ( "Bytes" ), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.UserDataStripeDepthMax", 
          "CIM_StorageSetting.UserDataStripeDepth" }, 
       PUnit ( "byte" )]
   uint64 UserDataStripeDepthMin;

      [Write, Description ( 
          "UserDataStripeDepth describes the number of bytes "
          "forming a strip in common striping-based storage "
          "organizations. The strip is defined as the size of the "
          "portion of a stripe that lies on one extent. Thus, "
          "ExtentStripeLength * UserDataStripeDepth will yield the "
          "size of one stripe of user data. When used in a goal "
          "setting instance, UserDataStripeDepthMax is the maximum "
          "acceptable value. The desired Stripe Depth is specified "
          "using UserDataStripeDepthGoal, while the minimum is "
          "defined by UserDataStripeDepthMin. "
          "UserDataStripeDepthMax MUST be set to NULL if the "
          "scoping StorageCapablities indicates that it is not "
          "supported in this context. If the property is supported, "
          "and is part of StorageSettingwWithHints it MAY be set to "
          "NULL. If used it will constrain the effects of Hint "
          "selections. When used in a Setting instance associated "
          "to a Volume, this property is set to the specific value "
          "of UserDataStripeDepth." ), 
       Units ( "Bytes" ), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.UserDataStripeDepthMin", 
          "CIM_StorageSetting.UserDataStripeDepth" }, 
       PUnit ( "byte" )]
   uint64 UserDataStripeDepthMax;

      [Experimental, Description ( 
          "True indicates delta replicas associated with the source "
          "element associated with this settingdata are "
          "incrementally dependent. Only the oldest replica in the "
          "set may be deleted or resynced." )]
   boolean IncrementalDeltas;

      [Experimental, Description ( 
          "True indicates the associated replicas persist during "
          "power off or system reset. False indicates replicas lost "
          "during these events." )]
   boolean PersistentReplica;

      [Experimental, Write, Description ( 
          "\"Not Applicable\" indicates that this property is not "
          "applicable to the associated storage element. Other "
          "values indicate whether or not remote mirror pair "
          "created with SynchronizationType \"Async\" is allowed to "
          "use a write buffer for asynchronous buffering. These "
          "other values are defined as: \n"
          "- \"Not Managed\": use or not of the buffer is up to the "
          "implementation. \n"
          "- \"Use Buffer\": use of a buffer for logging is "
          "required. \n"
          "- \"Do Not Use Buffer\": a buffer for logging shall not "
          "be used." ), 
       ValueMap { "0", "1", "2", "3", "..", "0x8000.." }, 
       Values { "Not Applicable", "Not Managed", "Use Buffer", 
          "Do Not Use Buffer", "DMTF Reserved", "Vendor Specific" }, 
       ModelCorrespondence { 
          "CIM_StorageReplicationCapabilities.UseReplicationBufferDefault" }]
   uint16 UseReplicationBuffer = 0;

      [Experimental, Write, Description ( 
          "Not Applicable indicates that this property is not "
          "applicable to the associated storage element. Other "
          "values indicate whether or not a source element should "
          "be fully copied to a target element at the time the "
          "replication is initiated. The provider does not have to "
          "comply with the client request. These other values are "
          "defined as: \n"
          "- \"Not Managed\": to start or not at initiation is up "
          "to the implementation. \n"
          "- \"Start\": start replication on initiation. \n"
          "- \"Do Not Start\": do not start replication on "
          "initiation." ), 
       ValueMap { "0", "1", "2", "3", "..", "0x8000.." }, 
       Values { "Not Applicable", "Not Managed", "Start", 
          "Do Not Start", "DMTF Reserved", "Vendor Specific" }, 
       ModelCorrespondence { 
          "CIM_StorageReplicationCapabilities.InitialSynchronizationDefault" }]
   uint16 InitialSynchronization = 0;

      [Experimental, Write, Description ( 
          "Not Applicable indicates that this property is not "
          "applicable to the associated storage element. Other "
          "values indicate the relative priority of background "
          "Replication I/O operations relative to host I/O "
          "operations. These other values are: \n"
          "- \"Low\": Replication engine I/O lower priority than "
          "host I/O. \n"
          "- \"Same\": Replication engine I/O has the same priority "
          "as host I/O. \n"
          "- \"High\": Replication engine I/O has higher priority "
          "than host I/O." ), 
       ValueMap { "0", "1", "2", "3", "4", "..", "0x8000.." }, 
       Values { "Not Applicable", "Not Managed", "Low", "Same", 
          "High", "DMTF Reserved", "Vendor Specific" }, 
       ModelCorrespondence { 
          "CIM_StorageReplicationCapabilities.ReplicationPriorityDefault" }]
   uint16 ReplicationPriority;

      [Experimental, Description ( 
          "SpaceLimit is the consumption limit for the allocated "
          "storage element from all associated StoragePools. If "
          "asserted, then the assumption is that the storage "
          "element can grow, (for instance an element representing "
          "the storage for a delta replica). \n"
          "If SpaceLimit is greater than zero, the space consumed "
          "by the storage element shall not exceed the value of "
          "SpaceLimit. \n"
          "If SpaceLimit = 0 (the default) then no limits are "
          "asserted on the amount of space consumed." ), 
       Units ( "Bytes" ), 
       PUnit ( "byte" )]
   uint64 SpaceLimit = 0;

      [Experimental, Description ( 
          "If the associated storage element may dynamically "
          "consume an increasing amount of space and a space limit "
          "is enforced on the element, then a non-zero warning "
          "threshold percentage indicates when a warning indication "
          "should be generated based on the total amount of space "
          "consumed being >= "
          "(SpaceLimit*SpaceLimitWarningThreshold)/100." ), 
       Units ( "Percentage" ), 
       MinValue ( 0 ), 
       MaxValue ( 100 ), 
       PUnit ( "percent" )]
   uint16 SpaceLimitWarningThreshold;

      [Experimental, Description ( 
          "LowSpaceWarningThreshold simplifies the creation of a "
          "pool specific Indication based on RemainingManagedSpace "
          "<= \n"
          "(TotalManagedSpace*LowSpaceWarningThreshold)/100. One "
          "example client for an Indication based on this property "
          "is a delta copy implementation where the pool enables "
          "continuous, variable space consumption for the delta "
          "storage. Another example client for an Indication based "
          "on this property is a provisioning manager implementing "
          "a policy for adding storage to a pool when it becomes "
          "low." ), 
       Units ( "Percentage" ), 
       MinValue ( 0 ), 
       MaxValue ( 100 ), 
       ModelCorrespondence { "CIM_StoragePool.RemainingManagedSpace" }, 
       PUnit ( "percent" )]
   uint16 LowSpaceWarningThreshold;

      [Experimental, Write, Description ( 
          "The Usage value to be used when creating a new element "
          "that is derived from a StorageExtent.\n"
          "\n"
          "\"Reserved to be Unrestricted Pool Contributor\": "
          "Indicates the element is available and it is intended to "
          "be used as an Unrestricted Pool Contributor. Once such "
          "element is in use, the elements Usage value will change "
          "to \"In use as Unrestricted Pool Contributor\"." ), 
       ValueMap { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", 
          "11", "12", "13", "14", "15", "16", "17", "18", "19", 
          "20", "21", "22", "23", "24", "..", "32768..65535" }, 
       Values { "Other", "Unrestricted", 
          "Reserved for ComputerSystem (the block server)", 
          "Reserved by Replication Services", 
          "Reserved by Migration Services", "Local Replica Source", 
          "Remote Replica Source", "Local Replica Target", 
          "Remote Replica Target", "Local Replica Source or Target", 
          "Remote Replica Source or Target", "Delta Replica Target", 
          "Element Component", 
          "Reserved to be Unrestricted Pool Contributor", 
          "Composite Volume Member", "Composite LogicalDisk Member", 
          "Reserved for Sparing", 
          "In use as Unrestricted Pool Contributor", 
          "Reserved to be Delta Replica Pool Contributor", 
          "Reserved to be Local Replication Pool Contributor", 
          "Reserved to be Remote Replication Pool Contributor", 
          "In use as Delta Replica Pool Contributor", 
          "In use as Local Replication Pool Contributor", 
          "In use as Remote Replication Pool Contributor", 
          "DMTF Reserved", "Vendor Reserved" }, 
       ModelCorrespondence { "CIM_StorageExtent.Usage" }]
   uint16 StorageExtentInitialUsage;

      [Experimental, Write, Description ( 
          "The Usage value to be used when creating a new StoragePool."
           ), 
       ValueMap { "1", "2", "3", "4", "5", "6", "7", "8", "..", 
          "32768..65535" }, 
       Values { "Other", "Unrestricted", 
          "Reserved for ComputerSystem (the block server)", 
          "Reserved as a Delta Replica Container", 
          "Reserved for Migration Services", 
          "Reserved for Local Replication Services", 
          "Reserved for Remote Replication Services", 
          "Reserved for Sparing", "DMTF Reserved", "Vendor Reserved" }, 
       ModelCorrespondence { "CIM_StoragePool.Usage" }]
   uint16 StoragePoolInitialUsage;

      [Experimental, Description ( 
          "This property is the Node Element Descriptor of the "
          "Control Unit Image (this property is required for CKD "
          "StorageVolume). It is not required for LogicalDisks." )]
   string CUImage;

      [Experimental, Description ( "Type of data organization used." ), 
       ValueMap { "0", "1", "2", "3", "4" }, 
       Values { "Other", "Unknown", "Fixed Block", "Variable Block", 
          "Count Key Data" }]
   uint16 DataOrganization;

      [Experimental, Description ( 
          "Enumeration indicating the type of DiskDrives which may "
          "be available." ), 
       ValueMap { "0", "1", "2", "3", "4" }, 
       Values { "Do Not Care", "Other", "Hard Disk Drive", 
          "Solid State Drive", "Hybrid" }]
   uint16 DiskType;

      [Experimental, Description ( 
          "Specifies the specific device (e.g., 3380 or 3390) that "
          "is emulated by the volume." )]
   string EmulatedDevice;

      [Experimental, Description ( 
          "This property reflects support of the encryption feature "
          "implemented by some disk drives." ), 
       ValueMap { "0", "1", "2" }, 
       Values { "Do Not Care", "Not Supported", "Supported" }]
   uint16 Encryption;

      [Experimental, Description ( 
          "Enumeration indicating the type of form factors which "
          "may be available." ), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6" }, 
       Values { "Do Not Care", "Other", "Not Reported", "5.25 inch", 
          "3.5 inch", "2.5 inch", "1.8 inch" }]
   uint16 FormFactorType;

      [Experimental, Description ( 
          "Enumeration indicating the type of disk interfaces which "
          "may be available." ), 
       ValueMap { "0", "1", "2", "3", "4", "5" }, 
       Values { "Do Not Care", "other", "SAS", "SATA", "SAS/SATA", 
          "FC" }]
   uint16 PortType;

      [Experimental, Description ( 
          "This property is the Subsystem ID if the array or "
          "virtualizer supports Subsystem IDs. If they are "
          "supported they would be required on volume creation." )]
   string SubsystemID;

      [Experimental, Description ( 
          "The initial reserve being requested by the client when "
          "StorageConfigurationCapabilities is used as a parameter "
          "for creating volumes or logical disks." ), 
       Units ( "Bytes" ), 
       ModelCorrespondence { 
          "CIM_StorageConfigurationCapabilities.ThinProvisionedClientSettableReserve", 
          "CIM_StorageConfigurationCapabilities.ThinProvisionedDefaultReserve" }, 
       PUnit ( "byte" )]
   uint64 ThinProvisionedInitialReserve = 0;

      [Experimental, Description ( 
          "The type of thin provisioned pool used when "
          "StorageSetting is used as a goal for creating a thin "
          "provisioned pool. In other contexts, this property is "
          "undefined. The possibles values match the appropriate "
          "values in "
          "StorageConfigrationCapabilities.SupportedStorageElementTypes."
           ), 
       ValueMap { "7", "8", "9", "..", "0x800..0xFFFF" }, 
       Values { "ThinlyProvisionedAllocatedStoragePool", 
          "ThinlyProvisionedQuotaStoragePool", 
          "ThinlyProvisionedLimitlessStoragePool", "DMTF Reserved", 
          "Vendor Specific" }, 
       ModelCorrespondence { 
          "CIM_StorageConfigurationCapabilities.SupportedStorageElementTypes" }]
   uint16 ThinProvisionedPoolType;

      [Experimental, Description ( 
          "The CompressedElement property indicates whether or not "
          "compression of the element is being requested. When set "
          "to true, compression is being requested. When set to "
          "false, compression is not being requested." ), 
       ModelCorrespondence { "CIM_StorageSetting.CompressionRate" }]
   boolean CompressedElement = false;

      [Experimental, Write, Description ( 
          "Indicates the desired compression for a storage element. "
          "The possible values are \"None\", \"High\", \"Medium\", "
          "\"Low\" or \"Implementation Decides\". If "
          "CompressedElement is set to \"false\", then this "
          "property should be set to 1 (None)." ), 
       ValueMap { "1", "2", "3", "4", "5", "..", "32768..65535" }, 
       Values { "None", "High", "Medium", "Low", 
          "Implementation Decides", "DMTF Reserved", 
          "Vendor Specific" }, 
       ModelCorrespondence { "CIM_StorageSetting.CompressedElement" }]
   uint16 CompressionRate = 1;

      [Experimental, Description ( 
          "The speed of disk interconnection wanted. Value of 0 "
          "means don\'t care. Values are in bits/second" ), 
       PUnit ( "bit / second" )]
   uint64 InterconnectSpeed;

      [Experimental, Description ( 
          "Enumeration indicating the type of disk interconnection wanted."
           ), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6" }, 
       Values { "don\'t care", "other", "SAS", "SATA", "SAS/SATA", 
          "FC", "SOP" }]
   uint16 InterconnectType;

      [Experimental, Description ( 
          "The rotational speed of disk media wanted. a value of "
          "0xffffffff means don\'t care. Values are in revolutions "
          "per minute. SSD devices shall report 0." ), 
       PUnit ( "revolution / minute" )]
   uint32 RPM;


};



   [Version( "2.40.0" ), Description("{0}")]
class UNIX_StorageSetting : CIM_StorageSetting
{


};

